

/* DO NOT edit this file by hand. It is generated by the AVS make
 * system and any changes you make will be lost.
 */

import avs_core = require('./avs_core');
import avs_pc, {UserMediaHandler, AudioStreamHandler, VideoStreamHandler} from './avs_pc';


%CONSTANTS%
%STRUCTS%
%CALLBACK_TYPES%

let instance: Wcall | undefined;
let logFn: WcallLogHandler;

const logHandler: WcallLogHandler = (level, msg, err) => {
  if (logFn)
    logFn(level, msg, err);
  else {
    if (err)
      console.log(msg, err);
    else
      console.log(msg);
  }
}

export class Wcall {
  private em_module: any;

  constructor(em_module: any) {
    this.em_module = em_module;
  }

%FUNCTIONS%

  setUserMediaHandler(userMediaHandler: UserMediaHandler): void {
    avs_pc.setUserMediaHandler(userMediaHandler);
  }

  setAudioStreamHandler(audioStreamHandler: AudioStreamHandler): void {
    avs_pc.setAudioStreamHandler(audioStreamHandler);
  }

  setVideoStreamHandler(videoStreamHandler: VideoStreamHandler): void {
    avs_pc.setVideoStreamHandler(videoStreamHandler);
  }

  isConferenceCallingSupported() : boolean {
    return avs_pc.isConferenceCallingSupported();
  }

  replaceTrack(convid: string, newTrack: MediaStreamTrack): void {
    avs_pc.replaceTrack(convid, newTrack);
  }

  getStats(convid: string): Promise<Array<{userid: string, stats: RTCStatsReport}>> {
      return avs_pc.getStats(convid);
  }
  
  static supportsConferenceCalls(): boolean {
    const pt : any = RTCRtpSender.prototype;  
    const insertable_legacy = !!pt.createEncodedVideoStreams;
    const insertable_streams = !!pt.createEncodedStreams;

    return insertable_legacy || insertable_streams;
  }
};

export const getAvsInstance = function(): Promise<Wcall> {
  if (instance) {
    return Promise.resolve(instance);
  }

  return new Promise(resolve => {
    avs_core().then((em_module: any) => {
      instance = new Wcall(em_module);
      resolve(instance);
    });
  });
};

